%{
...
Created on   26/2/2020 17:53
Modified on 2/7/22 20:21: added the initial guess part for halo orbit

This file calculates the Initial Guess for Differential Correction.

Inputs
------
1) PointLoc - Lagrange Points - Provide (1/2/3) as inputs
2) orbitType - Input the Orbit type - 'lyapunov'/'halo'
3) m - required for halo orbit


Outputs
--------
for all families
1) XGuess(1 and 2) - Guess for the initial point, a structure file containing
        * XGuess(1,:) - First guess
        * XGuess(2,:) - Second Guess 
Note: 
XGuess(i,:) - Guess in 3 Dimension(1 x 6) vector

Dependencies
------------
1) GlobalData - Takes "mu,Ax1,Ax2" for calculation fro .

Note: Change Ax1 and Ax2 values in "Globaldata"

Reference
----------
1) Wang Sang Koon, Martin W Lo,JE Marsden, Shane D Ross - "Dynamical
   Systems,the Three Body Problem and Space Mission Design", 2011
   (see chapter 4 (Sec 4.4 - Step 2) for description)
...
%}
function[XGuess] = InitialGuess(PointLoc,G_var, orbitType, m)


Ax1 = G_var.Constants.Ax1;
Ax2 = G_var.Constants.Ax2;
mu = G_var.Constants.mu;

switch orbitType
    case 'lyapunov'
        switch PointLoc %Location of Equilibruim (L1/L2/L3)
            case 1
                x_e = G_var.LagPts.L1;
                mu_bar = mu*abs(x_e(1) -1+mu)^-3 + (1-mu)*abs(x_e(1) + mu)^-3 ;
                nu = sqrt(-0.5*(mu_bar-2-sqrt(9*mu_bar^2-8*mu_bar)));
                Tau = -(nu^2 + 2*mu_bar+1)/(2*nu);
                nu_y0.one = -Ax1*nu*Tau;
                nu_y0.two = -Ax2*nu*Tau;
                XGuess(1,:) = [(x_e(1)-Ax1),0, 0, 0,nu_y0.one, 0];
                XGuess(2,:) = [(x_e(1)-Ax2),0, 0, 0,nu_y0.two, 0];

            case 2
                Ax1 = -Ax1;
                Ax2 = -Ax2;
                x_e = G_var.LagPts.L2;
                mu_bar = mu*abs(x_e(1) -1+mu)^-3 + (1-mu)*abs(x_e(1) + mu)^-3 ;
                nu = sqrt(-0.5*(mu_bar-2-sqrt(9*mu_bar^2-8*mu_bar)));
                Tau = -(nu^2 + 2*mu_bar+1)/(2*nu);
                nu_y0.one = -Ax1*nu*Tau;
                nu_y0.two = -Ax2*nu*Tau;
                XGuess(1,:) = [(x_e(1)-Ax1),0, 0, 0,nu_y0.one, 0];
                XGuess(2,:) = [(x_e(1)-Ax2),0, 0, 0,nu_y0.two, 0];


            case 3
                x_e = G_var.LagPts.L3;
                mu_bar = mu*abs(x_e(1) -1+mu)^-3 + (1-mu)*abs(x_e(1) + mu)^-3 ;
                nu = sqrt(-0.5*(mu_bar-2-sqrt(9*mu_bar^2-8*mu_bar)));
                Tau = -(nu^2 + 2*mu_bar+1)/(2*nu);
                nu_y0.one = -Ax1*nu*Tau;
                nu_y0.two = -Ax2*nu*Tau;
                XGuess(1,:) = [(x_e(1)-Ax1),0, 0, 0,nu_y0.one, 0];
                XGuess(2,:) = [(x_e(1)-Ax2),0, 0, 0,nu_y0.two, 0];

        end
    case 'halo'
        delm = 2-m;
        switch PointLoc
            case 1
                dir = +1;
                gamma = G_var.LagPts.L1.gamma;
            case 2
                dir = -1;
                gamma = G_var.LagPts.L1.gamma;
        end
        c2 = 1/gamma^3*((dir)^2*mu+(-1)^2*(1-mu)*gamma^(2+1)/(1-dir*gamma)^(2+1));
        c3 = 1/gamma^3*((dir)^3*mu+(-1)^3*(1-mu)*gamma^(3+1)/(1-dir*gamma)^(3+1));
        c4 = 1/gamma^3*((dir)^4*mu+(-1)^4*(1-mu)*gamma^(4+1)/(1-dir*gamma)^(4+1));
        lambda = sqrt((c2+sqrt(9*c2^2-8*c2))/2);
        wp = sqrt((2-c2+sqrt(9*c2^2-8*c2))/2);
        wv = sqrt(c2);
        kappa = 2*lambda/(lambda^2+1-c2);
        d1 = 3*lambda^2/kappa*(kappa*(6*lambda^2-1)-2*lambda);
        d2 = 8*lambda^2/kappa*(kappa*(11*lambda^2-1)-2*lambda);
        a21 = 3*c3*(kappa^2-2)/(4*(1+2*c2));
        a22 = 3*c3/(4*(1+2*c2));
        a23 = -3*c3*lambda*(3*kappa^3*lambda-6*kappa*(kappa-lambda)+4)/(4*kappa*d1);
        a24 = -3*c3*lambda*(2+3*kappa*lambda)/(4*kappa*d1);
        b21 = -3*c3*lambda*(3*kappa*lambda-4)/(2*d1);
        b22 = -3*c3*lambda/d1;
        d21 = -c3/(2*lambda^2);
        a31 = -9*lambda*(4*c3*(kappa*a23-b21)+kappa*c4*(4+kappa^2))/(4*d2)...
            + (9*lambda^2+1-c2)*(3*c3*(2*a23-kappa*b21)+c4*(2+3*kappa^2))/(2*d2);
        a32 = -9*lambda*(4*c3*(3*kappa*a24-b22)+kappa*c4)/(4*d2)...
            + 3*(9*lambda^2+1-c2)*(c3*(kappa*b22+d21-2*a24)-c4)/(2*d2);
        b31 = 3*8*lambda*(3*c3*(kappa*b21-2*a23)-c4*(2+3*kappa^2))/(8*d2)...
            +3*((9*lambda^2+1+2*c2)*(4*c3*(kappa*a23-b21))+kappa*c4*(4+kappa^2))/(8*d2);
        b32 = 9*lambda*(c3*(kappa*b22+d21-2*a24)-c4)...
            +3*(9*lambda^2+1+2*c2)*(4*c3(kappa*a24-b22)+kappa*c4)/(8*d2);
        d31 = 3*(4*c3*a24+c4)/(64*lambda^2);
        d32 = 3*(4*c3*(a23-d21)+c4*(4+kappa^2))/(64*lambda^2);
        s1 = (2*lambda*(lambda*(1+kappa^2)-2*kappa))^(-1)*(3/2*c3*(2*a21*(kappa^2-2)...
            -a23*(kappa^2+2)-2*kappa*b21) - 3/8*c4*(3*kappa^4-8*kappa^2+8));
        s2 = (2*lambda*(lambda*(1+kappa^2)-2*kappa))^(-1)*(3/2*c3*(2*a22*(kappa^2-2)...
            -a24*(kappa^2+2)-2*kappa*b22+5*d21) + 3/8*c4*(12-kappa^2));
        l1 = -3/2*c3*(2*a21+a23+5*d21)-3/8*c4*(12-kappa^2)+2*lambda^2*s1;
        l2 = 3/2*c3*(a24-a22)+9/8*c4+2*lambda^2*s2;
        delta = wp^2-c2;
        Ax = sqrt(abs(delta/l1))+0.001;
        Az = sqrt((-delta-l1*Ax^2)/l2);
        nu2 = s1*Ax^2+s2*Az^2;
        nu = 1+nu2;

        x0 = a21*Ax^2+a22*Az^2-Ax+a23*Ax^2-a24*Az^2+a31*Ax^3-a32*Ax*Az^2;
        z0 = delm*Az+delm*d21*Ax*Az*(-3)+delm*(d32*Az*Ax^2-d31*Az^3);
        ydot0 = kappa*Ax+2*(b21*Ax^2-b22*Az^2)+3*(b31*Ax^3-b32*Ax*Az^2);

        x0 = gamma*x0-dir*gamma+1-mu;
        z0 = gamma*z0;
        ydot0 = gamma*wp*nu*ydot0;

        XGuess(1,:) = [x0,0, z0, 0,ydot0, 0];
        Ax = 2*Ax;
        Az = sqrt((-delta-l1*Ax^2)/l2);
        nu2 = s1*Ax^2+s2*Az^2;
        nu = 1+nu2;

        x0 = a21*Ax^2+a22*Az^2-Ax+a23*Ax^2-a24*Az^2+a31*Ax^3-a32*Ax*Az^2;
        z0 = delm*Az+delm*d21*Ax*Az*(-3)+delm*(d32*Az*Ax^2-d31*Az^3);
        ydot0 = kappa*Ax+2*(b21*Ax^2-b22*Az^2)+3*(b31*Ax^3-b32*Ax*Az^2);

        x0 = gamma*x0-dir*gamma+1-mu;
        z0 = gamma*z0;
        ydot0 = gamma*wp*nu*ydot0;
        XGuess(2,:) = [x0,0, z0, 0,ydot0, 0];
end
