function [xAns] = ContinuationBifurcation(xLower, xUpper, globalVar)

tol = globalVar.userInput.tolerance*10^2;
mu = globalVar.userInput.mu;
funVarEq = globalVar.functions.varEq_stmDot;
switch globalVar.userInput.orbit
    case 'lyapunov'
        for i = 1:length(xLower.period)
            if xLower.stabilityIdx(i).center < 1
                bifurcationType = 1;
            else
                bifurcationType = 2;
            end
            while abs(xUpper.stabilityIdx(i).center-xLower.stabilityIdx(i).center) > tol
                delta = 1/2*(xUpper.IC(i,:)-xLower.IC(i,:));
                xGuess = xLower.IC(i,:) + delta;
                [~,~,~,isMaxIterReached] = diffCorrec(xGuess,globalVar);
                while isMaxIterReached
                    delta = delta/2;
                    xGuess = xLower.IC(i,:) + delta;
                    [~,~,~,isMaxIterReached] = diffCorrec(xGuess,globalVar);
                end
                [tMid(1),xMid(1,:),~,~] = diffCorrec(xGuess,globalVar);
                [~,monodromy,~,~] = stm_X(globalVar,xMid,funVarEq,tMid);
                [eigens.val.stable,eigens.val.unstable,eigens.val.center,eigens.val.p,eigens.vec.stable,...
            eigens.vec.unstable,eigens.vec.center,eigens.vec.p] = calcEigen(monodromy,1) ;
                stabilityIdx = calcStabilityIdx(eigens);
                if StabilityIdx.C < 1 && bifurcationType == 1 || StabilityIdx.C > 1 && bifurcationType == 2
                    xLower.IC(i,:) = xMid(1,:);
                    xLower.period(i) = tMid;
                    xLower.jacobianConst(i) = jacobiValue3D(xMid(i,:),mu);
                    xLower.monodromy(:,:,i) = monodromy;
                    xLower.eigens(i) = eigens;
                    xLower.stabilityIdx(i) = stabilityIdx;

                else
                    xUpper.IC(i,:) = xMid(1,:);
                    xUpper.period(i) = tMid;
                    xUpper.energy(i) = jacobiValue3D(xMid(i,:),mu);
                    xUpper.monodromy(:,:,i) = monodromy;
                    xUpper.eigens(i) = eigens;
                    xUpper.stabilityIdx(i) = stabilityIdx;
                end
            end
            delta = 1/2*(xUpper.IC(i,:)-xLower.IC(i,:));
            xGuess = xLower.IC(i,:) + delta;
            [~,~,~,isMaxIterReached] = diffCorrec(xGuess,globalVar);
            while isMaxIterReached
                delta = delta/2;
                xGuess = xLower.IC(i,:) + delta;
                [~,~,~,isMaxIterReached] = diffCorrec(xGuess,globalVar);
            end
            [tMid(i),xMid(i,:),~,~] = diffCorrec(xGuess,globalVar);
            [~,monodromy,~,~] = stm_X(globalVar,xMid(i,:),funVarEq,tMid);
            [eigens.val.stable,eigens.val.unstable,eigens.val.center,eigens.val.p,eigens.vec.stable,...
            eigens.vec.unstable,eigens.vec.center,eigens.vec.p] = calcEigen(monodromy,1) ;
                stabilityIdx = calcStabilityIdx(eigens);
            xAns.eigens(i) = eigens;
            xAns.stabilityIdx(i,1) = stabilityIdx;
            xAns.period(i) = tMid(i);
            xAns.monodromy(:,:,i) = monodromy;
            xAns.IC(i,:) = xMid(i,:);
            xAns.jacobianConst(i) = jacobiValue3D(xMid(i,:),mu);
        end
    case 'halo'
        delX0 = [0 0 1 0 0 0];
        S = 0.01;
        for i = 1:length(xLower.time)
            if xLower.stabilityIdx(i).center < 1
                bifurcationType = 1;
            else
                bifurcationType = 2;
            end
            while abs(xUpper.stabilityIdx(i).center-xLower.stabilityIdx(i).C) > tol
                delta = delX0*S;
                xGuess = xLower.IC(i,:) + delta;
                [~,~,~,isMaxIterReached] = DiffCorrec(xGuess,0,globalVar,'halo');
                while isMaxIterReached
                    delta = delta/2;
                    xGuess = xLower(i,:) + delta;
                    [~,~,~,isMaxIterReached] = DiffCorrec(xGuess,0,globalVar,'halo');
                end
                [tMid(i,1),xMid(i,:),~,~] = DiffCorrec(xGuess,0,globalVar,'halo');
                Energy(i,1) = jacobiValue3D(xMid(i,:),mu);
                S = (xMid(i,3) - xLower.IC(i,3));
                [~,monodromy,~,~] = StateTransAndX(globalVar,xMid,funVarEq,tMid);
                [eigens.S_EigVal,eigens.US_EigVal,eigens.C_Val,eigens.P_EigVal,eigens.S_EigVec,...
            eigens.US_EigVec,eigens.C_EigVec,eigens.P_EigVec] = CalcEigenValVec(monodromy,1) ;
        
                StabilityIdx = CalcStabilityIdx(eigens);

                if StabilityIdx.C < 1 && bifurcationType == 1 || StabilityIdx.C > 1 && bifurcationType == 2
                    xLower.IC(i,:) = xMid(1,:);
                    xLower.time(i) = tMid;
                    xLower.Energy(i) = jacobiValue3D(xMid(i,:),mu);
                    xLower.Monodromy(:,:,i) = monodromy;
                    xLower.Eigens(i) = eigens;
                    xLower.StabilityIdx(i) = StabilityIdx;

                else
                    xUpper.IC(i,:) = xMid(1,:);
                    xUpper.time(i) = tMid;
                    xUpper.Energy(i) = jacobiValue3D(xMid(i,:),mu);
                    xUpper.Monodromy(:,:,i) = monodromy;
                    xUpper.Eigens(i) = eigens;
                    xUpper.StabilityIdx(i) = StabilityIdx;
                end
            end
            delta = 1/2*(xUpper.IC(i,:)-xLower.IC(i,:));
            xGuess = xLower.IC(i,:) + delta;
            [~,~,~,isMaxIterReached] = DiffCorrec(xGuess,0,globalVar);
            while isMaxIterReached
                delta = delta/2;
                xGuess = xLower.IC(i,:) + delta;
                [~,~,~,isMaxIterReached] = DiffCorrec(xGuess,0,globalVar);
            end
            [tMid(i),xMid(i,:),~,~] = DiffCorrec(xGuess,0,globalVar);
            [~,monodromy,~,~] = StateTransAndX(globalVar,xMid(i,:),funVarEq,tMid);
            [eigens.S_EigVal,eigens.US_EigVal,eigens.C_Val,eigens.P_EigVal,eigens.S_EigVec,...
                eigens.US_EigVec,eigens.C_EigVec,eigens.P_EigVec] = CalcEigenValVec(monodromy,1) ;
            StabilityIdx = CalcStabilityIdx(eigens);
            xAns.Eigens(i) = eigens;
            xAns.StabilityIdx(i,1) = StabilityIdx;
            xAns.time(i) = tMid(i);
            xAns.Monodromy(:,:,i) = monodromy;
            xAns.IC(i,:) = xMid(i,:);
            xAns.Energy(i) = jacobiValue3D(xMid(i,:),mu);
        end

end